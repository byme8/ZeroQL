using System;
using System.Collections.Generic;
using System.Linq;
using GraphQLParser;
using GraphQLParser.AST;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ZeroQL.Bootstrap.Generators;
using ZeroQL.Core.Enums;
using ZeroQL.Extensions;
using ZeroQL.Internal;
using ZeroQL.Schema;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace ZeroQL.Bootstrap;

public static class GraphQLGenerator
{
    public static string ToCSharp(string graphql, string clientNamespace, string? clientName)
    {
        var options = new GraphQlGeneratorOptions(clientNamespace, ClientVisibility.Public)
        {
            ClientName = clientName
        };

        return ToCSharp(graphql, options);
    }

    public static string ToCSharp(string graphql, GraphQlGeneratorOptions options)
    {
        var schema = Parser.Parse(graphql);
        var enums = schema.Definitions
            .OfType<GraphQLEnumTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(o => new EnumDefinition(
                o.Name.StringValue,
                o.Values?
                    .Select(v => v.Name.StringValue)
                    .ToArray()))
            .ToArray();

        var (queryType, mutationType) = GetQueryAndMutation(schema);
        var enumsNames = new HashSet<string>(enums.Select(o => o.Name));

        var scalarTypesFromSchema = schema.Definitions
            .OfType<GraphQLScalarTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(o => o.Name.StringValue)
            .ToArray();

        var scalarsToOverride = options.Scalars ?? new Dictionary<string, string>();
        var context = new TypeContext(options, enumsNames, scalarTypesFromSchema, scalarsToOverride);
        var customScalars = context.CustomScalars;

        var inputs = schema.Definitions
            .OfType<GraphQLInputObjectTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(o => CreateInputDefinition(context, o))
            .ToArray();

        var interfaces = schema.Definitions
            .OfType<GraphQLInterfaceTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(o => CreateInterfaceDefinition(context, o))
            .ToDictionary(o => o.Name);

        var types = schema.Definitions
            .OfType<GraphQLObjectTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(o => CreateTypesDefinition(context, interfaces, o))
            .ToArray();


        AddUnions(schema, interfaces, types);

        var namespaceDeclaration = NamespaceDeclaration(IdentifierName(options.ClientNamespace));
        var clientDeclaration = new[] { options.GenerateClient(queryType, mutationType) };
        var typesDeclaration = options.GenerateTypes(types, queryType, mutationType);
        var interfacesDeclaration = options.GenerateInterfaces(interfaces);
        var inputsDeclaration = options.GenerateInputs(inputs);
        var enumsDeclaration = GenerateEnums(options, enums);
        var scalarDeclaration = options.GenerateScalars(customScalars);
        var jsonInitializers = options.GenerateJsonInitializers(customScalars, enums, interfaces.Values);
        var interfaceInitializers = interfaces.GenerateInterfaceInitializers(types);

        var members = List<MemberDeclarationSyntax>(clientDeclaration)
            .AddRange(typesDeclaration)
            .AddRange(interfacesDeclaration)
            .AddRange(inputsDeclaration)
            .AddRange(scalarDeclaration)
            .AddRange(enumsDeclaration)
            .AddRange(interfaceInitializers)
            .Add(jsonInitializers);

        namespaceDeclaration = namespaceDeclaration
            .WithMembers(members);

        var warningCodes = options.WarningsToIgnore ?? new[] { "8618", "CS8603", "CS1066", "CS0618" };
        var disableWarning = PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)
            .WithErrorCodes(
                SeparatedList<ExpressionSyntax>(warningCodes
                    .Select(IdentifierName)));

        var namespacesToImport = new[]
        {
            "System",
            "System.Linq",
            "System.Text.Json.Serialization",
            "System.Text.Json.Nodes",
            "System.Text.Json",
            "ZeroQL",
            "ZeroQL.Json",
            "ZeroQL.Internal"
        };
        var checksum = ChecksumHelper.GenerateChecksumFromInlineSchema(graphql, options);

        namespaceDeclaration = namespaceDeclaration
            .WithLeadingTrivia(
                Comment($"// {checksum}"),
                Comment("// <auto-generated>"),
                Comment($"// This file generated for ZeroQL {ZeroQLGenerationInfo.Version}."),
                Comment("//"),
                Comment("// Do not modify this file manually. Any changes will be lost after regeneration."),
                Comment("// </auto-generated>"),
                Trivia(disableWarning),
                LineFeed,
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
                LineFeed)
            .WithUsings(
                List(namespacesToImport
                    .Select(o => UsingDirective(IdentifierName(o)))));

        var unit = CompilationUnit()
            .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclaration));

        unit = unit.AddMembers(GenerateNetstandardCompatibility());

        unit = FixTypeNamingWhenNameEqualsMemberName(unit);

        var formattedSource = unit
            .NormalizeWhitespace()
            .ToFullString()
            .Replace("\r\n", "\n")
            .Replace("\r", "\n");

        return formattedSource;
    }

    private static (string? Query, string? Mutation) GetQueryAndMutation(GraphQLDocument document)
    {
        var schemaDefinition = document.Definitions
            .OfType<GraphQLSchemaDefinition>()
            .FirstOrDefault();

        if (schemaDefinition is not null)
        {
            var queryTypeFromSchema = schemaDefinition.OperationTypes
                .FirstOrDefault(x => x.Operation == OperationType.Query)?
                .Type?
                .Name
                .StringValue;

            var mutationTypeFromSchema = schemaDefinition.OperationTypes
                .FirstOrDefault(x => x.Operation == OperationType.Mutation)?
                .Type?
                .Name
                .StringValue;

            return (queryTypeFromSchema, mutationTypeFromSchema);
        }

        var queryType = document.Definitions
            .OfType<GraphQLObjectTypeDefinition>()
            .FirstOrDefault(x => x.Name.StringValue == "Query");

        var mutationType = document.Definitions
            .OfType<GraphQLObjectTypeDefinition>()
            .FirstOrDefault(x => x.Name.StringValue == "Mutation");

        return (queryType?.Name.StringValue, mutationType?.Name.StringValue);
    }

    private static CompilationUnitSyntax FixTypeNamingWhenNameEqualsMemberName(
        CompilationUnitSyntax unit)
    {
        var classesWhenClassNameEqualsToPropertyName = unit
            .DescendantNodes()
            .OfType<ClassDeclarationSyntax>()
            .Where(o => o.Members
                            .OfType<PropertyDeclarationSyntax>()
                            .Any(p => p.Identifier.Text == o.Identifier.Text) ||
                        o.Members
                            .OfType<MethodDeclarationSyntax>()
                            .Any(m => SubstringGenericName(m.Identifier.Text) == o.Identifier.Text))
            .ToArray();

        var changedClasses = classesWhenClassNameEqualsToPropertyName
            .Select(o => (o.Identifier.Text, New: o.WithIdentifier(Identifier($"{o.Identifier.Text}ZeroQL"))))
            .ToDictionary(o => o.Text, o => o.New);

        unit = unit.ReplaceNodes(classesWhenClassNameEqualsToPropertyName,
            (oldNode, _) => changedClasses[oldNode.Identifier.Text]);

        var propertyTypes = unit
            .DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Select(o => o.Type)
            .ToArray();

        var methodTypes = unit
            .DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .Select(o => o.ReturnType)
            .ToArray();

        var methodParameters = unit
            .DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .SelectMany(o => o.ParameterList.Parameters)
            .Select(o => o.Type)
            .ToArray();

        var genericTypes = unit
            .DescendantNodes()
            .OfType<GenericNameSyntax>()
            .Select(o => o.TypeArgumentList.Arguments)
            .SelectMany(o => o)
            .ToArray();

        var types = propertyTypes
            .Concat(methodTypes)
            .Concat(methodParameters)
            .Concat(genericTypes)
            .ToArray();

        var identifies = types
            .SelectMany(GetIdentifiers)
            .Where(o => changedClasses.ContainsKey(o.Identifier.Text))
            .ToArray();

        var changedIdentifiers = identifies
            .Select(o => (Key: o, New: o.WithIdentifier(Identifier($"{o.Identifier.Text}ZeroQL"))))
            .ToDictionary(o => o.Key, o => o.New);

        unit = unit.ReplaceNodes(identifies,
            (oldNode, _) => changedIdentifiers[oldNode]);

        return unit;
    }

    private static IdentifierNameSyntax[] GetIdentifiers(TypeSyntax? typeSyntax)
    {
        return typeSyntax switch
        {
            IdentifierNameSyntax identifierNameSyntax => [identifierNameSyntax],
            ArrayTypeSyntax arrayTypeSyntax => GetIdentifiers(arrayTypeSyntax.ElementType),
            NullableTypeSyntax nullableTypeSyntax => GetIdentifiers(nullableTypeSyntax.ElementType),
            _ => Array.Empty<IdentifierNameSyntax>()
        };
    }

    private static string SubstringGenericName(string name)
    {
        var index = name.IndexOf('<');
        if (index == -1)
        {
            return name;
        }

        return name.Substring(0, index);
    }

    private static MemberDeclarationSyntax GenerateNetstandardCompatibility()
    {
        // Create the namespace declaration first
        var namespaceDeclaration = NamespaceDeclaration(IdentifierName("System.Runtime.CompilerServices"));
        
        // Create the attribute class
        var attributeClass = ClassDeclaration("ModuleInitializerAttribute")
            .AddModifiers(Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.SealedKeyword))
            .AddBaseListTypes(SimpleBaseType(IdentifierName("Attribute")))
            .AddAttributeLists(AttributeList()
                .AddAttributes(Attribute(IdentifierName("AttributeUsage"))
                    .AddArgumentListArguments(
                        AttributeArgument(MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName("AttributeTargets"),
                            IdentifierName("Method"))),
                        AttributeArgument(LiteralExpression(SyntaxKind.FalseLiteralExpression))
                            .WithNameEquals(NameEquals("Inherited")))));

        // Add the class to the namespace
        namespaceDeclaration = namespaceDeclaration.AddMembers(attributeClass);

        // Wrap with conditional compilation directives - include both NETSTANDARD2_0 and NETSTANDARD2_1
        var conditionalNamespace = namespaceDeclaration
            .WithLeadingTrivia(
                Comment("// Netstandard compatibility"),
                LineFeed,
                Trivia(IfDirectiveTrivia(
                    BinaryExpression(SyntaxKind.LogicalOrExpression,
                        IdentifierName("NETSTANDARD2_0"),
                        IdentifierName("NETSTANDARD2_1")), true, false, false)))
            .WithTrailingTrivia(
                Trivia(EndIfDirectiveTrivia(true)),
                LineFeed);

        return conditionalNamespace;
    }

    private static ClassDefinition CreateTypesDefinition(
        TypeContext typeContext,
        Dictionary<string, InterfaceDefinition> interfaces,
        GraphQLObjectTypeDefinition type)
    {
        var typeInterfaces = type.Interfaces?
            .Select(o => interfaces[o.Name.StringValue])
            .ToList() ?? new List<InterfaceDefinition>();

        var interfacesFields = typeInterfaces
            .SelectMany(o => o.Properties)
            .ToArray();

        var classFields = new List<FieldDefinition>();
        var classDefinition = new ClassDefinition(type.Name.StringValue, classFields, typeInterfaces);
        var fields = typeContext.CreatePropertyDefinition(classDefinition, type.Fields, interfacesFields);
        classFields.AddRange(fields);

        return classDefinition;
    }

    private static InterfaceDefinition CreateInterfaceDefinition(
        TypeContext typeContext,
        GraphQLInterfaceTypeDefinition definition)
    {
        var names = definition.Interfaces?.Items
            .Select(o => o.Name.StringValue)
            .ToArray() ?? Array.Empty<string>();

        var interfaceFields = new List<FieldDefinition>();
        var interfaceDefinition = new InterfaceDefinition(definition.Name.StringValue, names, interfaceFields);
        var fields = typeContext.CreatePropertyDefinition(
            interfaceDefinition,
            definition.Fields,
            Array.Empty<FieldDefinition>());

        interfaceFields.AddRange(fields);

        return interfaceDefinition;
    }

    public static UnionDefinition CreateUnionDefinition(GraphQLUnionTypeDefinition union)
        => new(union.Name.StringValue,
            union.Types?.Select(o => o.Name.StringValue).ToArray() ?? Array.Empty<string>());

    private static ClassDefinition CreateInputDefinition(TypeContext typeContext,
        GraphQLInputObjectTypeDefinition input)
    {
        var classFields = new List<FieldDefinition>();
        var classDefinition = new ClassDefinition(input.Name.StringValue, classFields, new List<InterfaceDefinition>());
        var fields = typeContext.CreatePropertyDefinition(classDefinition, input.Fields);
        classFields.AddRange(fields);

        return classDefinition;
    }

    private static void AddUnions(GraphQLDocument schema,
        Dictionary<string, InterfaceDefinition> interfaces,
        ClassDefinition[] types)
    {
        var unions = schema.Definitions
            .OfType<GraphQLUnionTypeDefinition>()
            .OrderBy(o => o.Name.StringValue)
            .Select(CreateUnionDefinition)
            .ToArray();

        foreach (var union in unions)
        {
            var unionInterface = new InterfaceDefinition(
                union.Name,
                Array.Empty<string>(),
                Array.Empty<FieldDefinition>());

            interfaces.Add(union.Name, unionInterface);
            foreach (var unionType in union.Types)
            {
                var type = types.FirstOrDefault(o => o.Name == unionType);
                if (type is not null)
                {
                    type.Implements.Add(unionInterface);
                }
            }
        }
    }

    private static EnumDeclarationSyntax[] GenerateEnums(
        GraphQlGeneratorOptions options,
        EnumDefinition[] enums)
    {
        return enums.Select(e =>
            {
                var members = e.Values?.Select(o =>
                    {
                        var name = o.ToPascalCase();
                        return EnumMemberDeclaration(Identifier(name))
                            .AddAttributeWithStringParameter(ZeroQLGenerationInfo.GraphQLNameAttribute, o);
                    })
                    .ToArray() ?? Array.Empty<EnumMemberDeclarationSyntax>();

                var enumSyntax = EnumDeclaration(Identifier(e.Name))
                    .AddAttributeLists(AttributeList()
                        .AddAttributes(Attribute(ParseName(ZeroQLGenerationInfo.CodeGenerationAttribute))))
                    .AddMembers(members)
                    .AddModifiers(Token(
                        options.Visibility == ClientVisibility.Public
                            ? SyntaxKind.PublicKeyword
                            : SyntaxKind.InternalKeyword));

                return enumSyntax;
            })
            .ToArray();
    }
}